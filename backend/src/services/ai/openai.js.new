/**
 * Servicio de integraciÃ³n con OpenAI para procesar mensajes del usuario
 */
const OpenAI = require('openai');

// Inicializar cliente de OpenAI si hay una clave API disponible
let openai = null;
if (process.env.OPENAI_API_KEY) {
  openai = new OpenAI({
    apiKey: process.env.OPENAI_API_KEY
  });
}

/**
 * Sistema de instrucciones base para el modelo
 */
const baseSystemPrompt = `
Eres un asistente musical de Spotify Ãºtil y amigable.
Tu objetivo es ayudar al usuario a controlar Spotify mediante comandos en lenguaje natural.

CAPACIDADES:
- Reproducir mÃºsica (artistas, canciones, gÃ©neros, playlists)
- Pausar/reanudar reproducciÃ³n
- Saltar a canciÃ³n anterior/siguiente
- Ajustar volumen
- Buscar mÃºsica
- Crear y modificar playlists
- Proporcionar informaciÃ³n sobre artistas, canciones, etc.

INSTRUCCIONES:
1. Responde de forma concisa y conversacional.
2. Identifica la intenciÃ³n del usuario y los parÃ¡metros necesarios.
3. Proporciona respuestas amigables y centradas en mÃºsica.
4. Si no puedes realizar una acciÃ³n, explica amablemente por quÃ©.

FORMATO DE RESPUESTA:
Debes devolver un objeto JSON con los siguientes campos:
- action: la acciÃ³n a realizar (play, pause, next, previous, volume, search, etc.)
- parameters: objeto con parÃ¡metros relevantes para la acciÃ³n
- message: mensaje conversacional para responder al usuario

Ejemplos de acciones:
- "play": reproducir mÃºsica (requiere query o trackId)
- "pause": pausar reproducciÃ³n
- "resume": reanudar reproducciÃ³n
- "next": siguiente canciÃ³n
- "previous": canciÃ³n anterior
- "volume": ajustar volumen (requiere level: 0-100)
- "search": buscar mÃºsica (requiere query)
- "queue": aÃ±adir canciÃ³n a la cola (requiere query)
- "info": proporcionar informaciÃ³n (usa esta acciÃ³n cuando solo quieras responder sin realizar una acciÃ³n en Spotify)

Ejemplos de parÃ¡metros:
- query: "rock de los 80s", "canciones de Coldplay"
- trackId: "spotify:track:123456"
- playlistId: "spotify:playlist:123456"
- level: 60 (para volumen)
`;

/**
 * FunciÃ³n para procesar un mensaje del usuario utilizando OpenAI
 * @param {string} message - Mensaje del usuario
 * @returns {Object} - AcciÃ³n a realizar y mensaje de respuesta
 */
async function processMessage(message) {
  // Forzar uso de procesamiento simple para evitar errores de cuota
  console.log('Usando procesamiento simple (sin OpenAI) para evitar errores de cuota');
  return processMessageSimple(message);

  try {
    // Enviar mensaje a OpenAI
    const completion = await openai.chat.completions.create({
      model: "gpt-4o", // o "gpt-3.5-turbo" para un modelo mÃ¡s ligero y econÃ³mico
      messages: [
        { role: "system", content: baseSystemPrompt },
        { role: "user", content: message }
      ],
      response_format: { type: "json_object" }
    });

    // Extraer y procesar la respuesta
    const responseContent = completion.choices[0].message.content;
    const parsedResponse = JSON.parse(responseContent);

    // Validar que la respuesta tenga el formato correcto
    if (!parsedResponse.action || !parsedResponse.message) {
      throw new Error('La respuesta de OpenAI no tiene el formato esperado');
    }

    return parsedResponse;
  } catch (error) {
    console.error('Error procesando mensaje con OpenAI:', error);
    // Fallback al procesamiento simple si hay un error
    return processMessageSimple(message);
  }
}

/**
 * Procesamiento simple de mensajes (fallback si OpenAI no estÃ¡ disponible)
 * @param {string} message - Mensaje del usuario
 * @returns {Object} - AcciÃ³n a realizar y mensaje de respuesta
 */
function processMessageSimple(message) {
  console.log('\n\nâœ¨ PROCESAMIENTO DE MENSAJE âœ¨');
  console.log('ğŸ’¬ ENTRADA:', message);
  const lowerMessage = message.toLowerCase();
  let action = 'info';
  let parameters = {};
  let responseMessage = 'No estoy seguro de lo que quieres hacer. Prueba con comandos como "reproducir rock" o "pausar mÃºsica".';
  
  // Evaluar si el mensaje parece claramente una solicitud para aÃ±adir a la cola
  const isQueueRequest = 
    (lowerMessage.includes('cola') || lowerMessage.includes('queue')) && 
    (lowerMessage.includes('aÃ±ade') || lowerMessage.includes('agregar') || 
     lowerMessage.includes('pon') || lowerMessage.includes('aÃ±adir'));

  // AÃ±adir a la cola (si parece una solicitud de cola)
  if (isQueueRequest) {
    action = 'queue';
    let query = '';
    let matched = false;

    // Buscar patrones comunes para aÃ±adir a la cola con regex
    const regexPatterns = [
      /aÃ±ade\s+(.+?)\s+(a\s+la\s+cola|en\s+la\s+cola|a\s+cola|en\s+cola)/i,
      /aÃ±adir\s+(.+?)\s+(a\s+la\s+cola|en\s+la\s+cola|a\s+cola|en\s+cola)/i,
      /agrega\s+(.+?)\s+(a\s+la\s+cola|en\s+la\s+cola|a\s+cola|en\s+cola)/i,
      /agregar\s+(.+?)\s+(a\s+la\s+cola|en\s+la\s+cola|a\s+cola|en\s+cola)/i,
      /pon\s+(.+?)\s+(a\s+la\s+cola|en\s+la\s+cola|a\s+cola|en\s+cola)/i,
      /poner\s+(.+?)\s+(a\s+la\s+cola|en\s+la\s+cola|a\s+cola|en\s+cola)/i,
      /queue\s+(.+)$/i
    ];
    
    // Intentar encontrar coincidencia con regex
    for (const pattern of regexPatterns) {
      const match = lowerMessage.match(pattern);
      if (match && match[1]) {
        query = match[1].trim();
        matched = true;
        console.log(' DETECCIÃ“N: Consulta de cola encontrada');
        console.log('   â€¢ PatrÃ³n:', pattern);
        console.log('   â€¢ Coincidencia:', query);
        break;
      }
    }

    // Si no se ha encontrado patrÃ³n, intentar mÃ©todo alternativo
    if (!matched) {
      const queueTerms = ['cola', 'queue', 'aÃ±adir a la cola', 'agregar a la cola', 'en la cola'];
      for (const term of queueTerms) {
        if (lowerMessage.includes(term)) {
          const parts = lowerMessage.split(term);
          if (parts.length > 1) {
            if (parts[1].trim()) {
              query = parts[1].trim();
              matched = true;
              console.log(' DETECCIÃ“N: TÃ©rmino de cola encontrado');
              console.log('   â€¢ TÃ©rmino:', term);
              console.log('   â€¢ Consulta despuÃ©s:', query);
              break;
            } else if (parts[0].trim()) {
              // Buscar en la parte anterior del mensaje
              const preParts = parts[0].split(' ');
              const relevantParts = preParts.slice(Math.max(0, preParts.length - 5)).join(' ').trim();
              if (relevantParts && !relevantParts.match(/^(pon|poner|agregar?|aÃ±ad[ei]r?)$/i)) {
                query = relevantParts;
                matched = true;
                console.log(' DETECCIÃ“N: TÃ©rmino de cola encontrado (antes)');
                console.log('   â€¢ TÃ©rmino:', term);
                console.log('   â€¢ Consulta antes:', query);
                break;
              }
            }
          }
        }
      }
    }
    
    if (query) {
      console.log(' RESULTADO: Consulta para cola encontrada =>', query);
      // Procesar consulta para detectar mÃºltiples canciones
      const songQueries = [];
      // Buscar patrones de separaciÃ³n de canciones
      // 1. Canciones separadas por 'y', 'and', 'tambiÃ©n', etc.
      const splitByConjunctions = query.split(/\s+y\s+|\s+and\s+|\s+tambi[eÃ©]n\s+|\s+junto\s+con\s+|\s+adem[aÃ¡]s\s+de\s+/);
      // 2. Canciones separadas por comas
      let processedQueries = [];
      splitByConjunctions.forEach(part => {
        // Divide por comas, pero no dentro de frases como "Guns N' Roses"
        const comaSplit = part.split(/,\s*(?![^()]*\))/);
        processedQueries = [...processedQueries, ...comaSplit];
      });
      // Limpiar y agregar cada consulta
      processedQueries.forEach(songQuery => {
        const cleanQuery = songQuery.trim();
        if (cleanQuery && cleanQuery.length > 1) { // Evitar aÃ±adir consultas vacÃ­as o muy cortas
          songQueries.push(cleanQuery);
        }
      });
      // Si solo hay una canciÃ³n, usar acciÃ³n normal de queue
      if (songQueries.length === 1) {
        action = 'queue';
        parameters = { query: songQueries[0] };
        responseMessage = `AÃ±adiendo "${songQueries[0]}" a la cola de reproducciÃ³n`;
      }
      // Si hay mÃºltiples canciones, usar queue_multiple
      else if (songQueries.length > 1) {
        console.log(` MULTI-COLA: Detectadas ${songQueries.length} solicitudes de canciones`);
        songQueries.forEach((song, index) => {
          console.log(`   â€¢ [${index + 1}] ${song}`);
        });
        action = 'queue_multiple';
        parameters = { queries: songQueries };
        responseMessage = `AÃ±adiendo ${songQueries.length} canciones a la cola de reproducciÃ³n: ${songQueries.map(q => `"${q}"`).join(', ')}`;
      }
      else {
        action = 'info';
        responseMessage = 'No he entendido quÃ© canciones quieres aÃ±adir a la cola. IntÃ©ntalo con algo como "aÃ±ade Bohemian Rhapsody y Stairway to Heaven a la cola".';
      }
    } else {
      action = 'info';
      responseMessage = 'No he entendido quÃ© quieres aÃ±adir a la cola. IntÃ©ntalo con algo como "aÃ±ade Bohemian Rhapsody a la cola".';
    }
  }
  // Reproducir mÃºsica
  else if (lowerMessage.includes('reproduc') || lowerMessage.includes('play') || 
      (lowerMessage.includes('pon') && !isQueueRequest)) {
    action = 'play';
    // Si no es un comando complejo, extraer la consulta
    if (!lowerMessage.includes('volum') && !lowerMessage.includes('anterior') && 
        !lowerMessage.includes('siguiente') && !lowerMessage.includes('next') && 
        !lowerMessage.includes('prev')) {
      // Eliminar palabras clave de reproducciÃ³n para quedarnos con la consulta
      let query = lowerMessage;
      const playTerms = ['reproducir', 'reproduce', 'play', 'pon', 'poner', 'escuchar', 'escucha'];
      for (const term of playTerms) {
        if (lowerMessage.includes(term)) {
          const parts = lowerMessage.split(term);
          if (parts.length > 1 && parts[1].trim()) {
            query = parts[1].trim();
            break;
          }
        }
      }
      parameters = { query };
      responseMessage = `Reproduciendo "${query}"`;
    }
  }
  // Pausar reproducciÃ³n - evitar confusiÃ³n con tÃ­tulos de canciones
  else if ((lowerMessage.includes('pausa') && !isQueueRequest) || 
           (lowerMessage.includes('pause') && !isQueueRequest) || 
           (lowerMessage.includes('stop') && !isQueueRequest && lowerMessage.length < 15) || // Solo si es un comando corto
           (lowerMessage.includes('para') && !isQueueRequest && lowerMessage.length < 15)) {
    action = 'pause';
    responseMessage = 'Pausando la reproducciÃ³n';
    console.log('ğŸ”• COMANDO: Interpretando como pausa');
  }
  // Reanudar
  else if (lowerMessage.includes('contin') || lowerMessage.includes('resume') || lowerMessage.includes('reanudar')) {
    action = 'resume';
    responseMessage = 'Reanudando la reproducciÃ³n';
  }
  // Siguiente canciÃ³n
  else if (lowerMessage.includes('siguiente') || lowerMessage.includes('next') || lowerMessage.includes('salta')) {
    action = 'next';
    responseMessage = 'Pasando a la siguiente canciÃ³n';
  }
  // CanciÃ³n anterior
  else if (lowerMessage.includes('anterior') || lowerMessage.includes('prev') || lowerMessage.includes('previa')) {
    action = 'previous';
    responseMessage = 'Volviendo a la canciÃ³n anterior';
  }
  // Ajustar volumen
  else if (lowerMessage.includes('volumen') || lowerMessage.includes('volume') || 
           lowerMessage.includes('subir') || lowerMessage.includes('bajar') || 
           lowerMessage.includes('alto') || lowerMessage.includes('bajo')) {
    action = 'volume';
    let level = 50; // Valor por defecto
    
    if (lowerMessage.includes('subir') || lowerMessage.includes('aumenta') || lowerMessage.includes('mÃ¡s alto')) {
      level = 75;
    }
    else if (lowerMessage.includes('baja') || lowerMessage.includes('reduce') || lowerMessage.includes('mÃ¡s bajo')) {
      level = 25;
    }
    
    parameters = { level };
    responseMessage = `Ajustando volumen al ${level}%`;
  } 
  // Buscar
  else if (lowerMessage.includes('busca') || lowerMessage.includes('search') || lowerMessage.includes('encuentra')) {
    action = 'search';
    // Extraer tÃ©rminos de bÃºsqueda
    const queryTerms = ['buscar', 'busca', 'search', 'encuentra', 'encontrar'];
    let query = lowerMessage;
    for (const term of queryTerms) {
      if (lowerMessage.includes(term)) {
        const parts = lowerMessage.split(term);
        if (parts.length > 1 && parts[1].trim()) {
          query = parts[1].trim();
          break;
        }
      }
    }
    parameters = { query };
    responseMessage = `Buscando "${query}"`;
  }
  
  return {
    action,
    parameters,
    message: responseMessage
  };
}

module.exports = {
  processMessage
};
